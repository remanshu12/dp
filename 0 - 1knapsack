// https://www.geeksforgeeks.org/problems/0-1-knapsack-problem0945/1
////////////////////////////////////////////--------------------------------------------------- using recursion 

class Solution {
  public:
    int knapsack(int W, vector<int> &val, vector<int> &wt) {
        // code here
        int n=val.size();
       return helper(wt,val,W,n);
    }
    static int helper(vector<int> &wt,vector<int> &val,int W,int n){
        if(n==0 || W==0){
            return 0;
        }
        if(wt[n-1]<=W){
            return max(val[n-1]+helper(wt,val,W-wt[n-1],n-1),helper(wt,val,W,n-1));
        }else{
            return helper(wt,val,W,n-1);
        }
    }
};


///////------------------------------------------------------------------------------------ mathod -2 using dp


class Solution {
  public:
    int dp[1001][1001];
    int knapsack(int W, vector<int> &val, vector<int> &wt) {
        // code here
        int n=val.size();
          memset(dp, -1, sizeof(dp));
       return helper(wt,val,W,n);
    }
     int helper(vector<int> &wt,vector<int> &val,int W,int n){
        if(n==0 || W==0){
            return 0;
        }
        if(dp[n][W]!=-1){
            return dp[n][W];
        }
        if(wt[n-1]<=W){
            return dp[n][W]=max(val[n-1]+helper(wt,val,W-wt[n-1],n-1),helper(wt,val,W,n-1));
        }else{
            return dp[n][W]=helper(wt,val,W,n-1);
        }
    }
};
